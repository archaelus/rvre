%% File:    re.erl
%% Author:  Robert Virding
%% Purpose: POSIX regular expression matching
%%
%% This module provides a basic set of regular expression functions
%% for strings and binaries. The basic functions provided are taken
%% from AWK. There is a parallel set of functions which also return
%% values of the sub-expressions.

-module(re).

-export([sh_to_awk/1,parse/1,compile/1,compile/2,format_error/1]).
-export([match/2,match/3,best_match/2,best_match/3,matches/2,matches/3,
	 sub/3,sub/4,gsub/3,gsub/4,split/2,split/3]).

-import(string, [substr/2,substr/3]).
-import(lists, [reverse/1,reverse/2,duplicate/2]).
-import(lists, [member/2,usort/2,keysearch/3,keysort/2,keydelete/3]).
-import(lists, [map/2,foldl/3]).

%%-compile([export_all]).

%% This is the compile flags record which controls parser, compiler and engine.
-record(cflags, {ignore_case=false,		%Ignore case
		 newline=false,			%Where to anchor string|line
		 sub=false			%Return subexprs false|true
		}).

%% This is the nfa record generated by the compiler.
-record(nfa, {cflags=[],			%Compile-time flags
	      nfa=none,				%The NFA
	      start=none,			%Start state
	      nsub=0				%Sub-expressions
	     }).

%% This is the regular expression grammar used. It is equivalent to the
%% one used in AWK, except that we allow ^ $ to be used anywhere and fail
%% in the matching.
%%
%% reg -> alt : '$1'.
%% alt -> seq "|" seq ... : {alt,['$1','$2'...]}.
%% seq -> repeat repeat ... : {seq,['$1','$2'...]}.
%% repeat -> repeat "*" : {kclosure,'$1'}.
%% repeat -> repeat "+" : {pclosure,'$1'}.
%% repeat -> repeat "?" : {optional,'$1'}.
%% repeat -> repeat "{" [Min],[Max] "}" : {interval,'$1',Min,Max}
%% repeat -> single : '$1'.
%% single -> "(" reg ")" : {sub,'$2',Number}.
%% single -> "^" : bos/bol.
%% single -> "$" : eos/eol.
%% single -> "." : any.
%% single -> "[" class "]" : {char_class,char_class('$2')}
%% single -> "[" "^" class "]" : {comp_class,char_class('$3')}.
%% single -> "\"" chars "\"" : {lit,'$2'}.
%% single -> "\\" char : {lit,['$2']}.
%% single -> char : {lit,['$1']}.
%% single -> empty : epsilon.
%%  The grammar of the current regular expressions. The actual parser
%%  is a recursive descent implementation of the grammar.

reg(Cs0) ->
    {RE,Sc,Cs1} = reg(Cs0, 0),
    {ok,{RE,Sc},Cs1}.

reg(Cs, Sn) -> alt(Cs, Sn).

alt(Cs0, Sn0) ->
    {L,Sn1,Cs1} = seq(Cs0, Sn0),
    case alt1(Cs1, Sn1) of
	{[],Sn2,Cs2} -> {L,Sn2,Cs2};
	{Rs,Sn2,Cs2} -> {{alt,[L|Rs]},Sn2,Cs2}
    end.

alt1([$||Cs0], Sn0) ->
    {L,Sn1,Cs1} = seq(Cs0, Sn0),
    {Rs,Sn2,Cs2} = alt1(Cs1, Sn1),
    {[L|Rs],Sn2,Cs2};
alt1(Cs, Sn) -> {[],Sn,Cs}.

%% seq(Chars, SubNumber) -> {RegExp,SubNumber,Chars}.
%% Parse a sequence of regexps. Allow the empty sequence, returns epsilon.

seq(Cs0, Sn0) ->
    case seq1(Cs0, Sn0) of
	{[],Sn1,Cs1} -> {epsilon,Sn1,Cs1};
	{[R],Sn1,Cs1} -> {R,Sn1,Cs1};
	{Rs,Sn1,Cs1} -> {{seq,Rs},Sn1,Cs1}
    end.

%% Parse a sequence of regexps. Don't allow the empty sequence.
%% seq(Cs0, Sn0) ->
%%     {L,Sn1,Cs1} = repeat(Cs0, Sn0),
%%     case seq1(Cs1, Sn1) of
%% 	{[],Sn2,Cs2} -> {L,Sn2,Cs2};
%% 	{Rs,Sn2,Cs2} -> {{seq,[L|Rs]},Sn2,Cs2}
%%     end.

seq1([C|_]=Cs0, Sn0) when C /= $|, C /= $) ->
    {L,Sn1,Cs1} = repeat(Cs0, Sn0),
    {Rs,Sn2,Cs2} = seq1(Cs1, Sn1),
    {[L|Rs],Sn2,Cs2};
seq1(Cs, Sn) -> {[],Sn,Cs}.

repeat(Cs0, Sn0) ->
    {S,Sn1,Cs1} = single(Cs0, Sn0),
    repeat1(Cs1, Sn1, S).

repeat1([$*|Cs], Sn, S) -> repeat1(Cs, Sn, {kclosure,S});
repeat1([$+|Cs], Sn, S) -> repeat1(Cs, Sn, {pclosure,S});
repeat1([$?|Cs], Sn, S) -> repeat1(Cs, Sn, {optional,S});
repeat1([${|Cs0], Sn, S) ->			% $}
    case interval_range(Cs0) of
	{Min,Max,[$}|Cs1]} when is_integer(Min), is_integer(Max), Min =< Max ->
	    repeat1(Cs1, Sn, {interval,S,Min,Max});
	{Min,Max,[$}|Cs1]} when is_integer(Min), is_atom(Max) ->
	    repeat1(Cs1, Sn, {interval,S,Min,Max});
	_ -> parse_error({interval_range,"{"})
    end;
repeat1(Cs, Sn, S) -> {S,Sn,Cs}.

%% single(Chars, SubNumber) -> {RegExp,SubNumber,Chars}.
%% Parse a single regexp.

single([$(|Cs0], Sn0) ->			% $)
    Sn1 = Sn0 + 1,
    case reg(Cs0, Sn1) of
	{S,Sn2,[$)|Cs1]} -> {{sub,S,Sn1},Sn2,Cs1};
	_ -> parse_error({unterminated,"("})
    end;
single([$^|Cs], Sn) -> {bos,Sn,Cs};
single([$$|Cs], Sn) -> {eos,Sn,Cs};
single([$.|Cs], Sn) -> {any,Sn,Cs};
single("[^" ++ Cs0, Sn) ->
    case char_class(Cs0) of
	{Cc,[$]|Cs1]} -> {{comp_class,Cc},Sn,Cs1};
	_ -> parse_error({unterminated,"["})
    end;
single([$[|Cs0], Sn) ->
    case char_class(Cs0) of
	{Cc,[$]|Cs1]} -> {{char_class,Cc},Sn,Cs1};
	_ -> parse_error({unterminated,"["})
    end;
single([$\\|Cs0], Sn) ->
    {C,Cs1} = escape_char(Cs0),
    {{lit,[C]},Sn,Cs1};
single([C|Cs], Sn) ->
    case special_char(C) of
	true -> parse_error({illegal_char,[C]});
	false -> {{lit,[C]},Sn,Cs}
    end;
single([], _) ->
    parse_error(missing_char).

%% char_class(Chars) -> {CharClass,Chars}.
%% Parse a character class.

char_class([$]|Cs]) -> char_class(Cs, [$]]);	%Have to special case this.
char_class(Cs) -> char_class(Cs, []).

char_class("[:" ++ Cs0, Cc) ->			%Start of POSIX char class
    case posix_cc(Cs0) of
	{Pcl,":]" ++ Cs1} -> char_class(Cs1, [{posix,Pcl}|Cc]);
	{_,Cs1} -> parse_error({posix_cc,string_between(Cs0, Cs1)})
    end;
char_class([Cf,$-,Cl|Cs], Cc) when Cf /= $], Cl /= $] ->
    if Cf =< Cl -> char_class(Cs, [{range,Cf,Cl}|Cc]); 
       true -> parse_error({char_class,[Cf,$-,Cl]})
    end;
char_class([C|Cs], Cc) when is_integer(C), C /= $] ->
    char_class(Cs, [C|Cc]);
char_class(Cs, Cc) -> {reverse(Cc),Cs}.		%Preserve order

%% posix_cc(String) -> {PosixClass,RestString}.
%%  Handle POSIX character classes.

posix_cc("alnum" ++ Cs) -> {alnum,Cs};
posix_cc("alpha" ++ Cs) -> {alpha,Cs};
posix_cc("blank" ++ Cs) -> {blank,Cs};
posix_cc("cntrl" ++ Cs) -> {cntrl,Cs};
posix_cc("digit" ++ Cs) -> {digit,Cs};
posix_cc("graph" ++ Cs) -> {graph,Cs};
posix_cc("lower" ++ Cs) -> {lower,Cs};
posix_cc("print" ++ Cs) -> {print,Cs};
posix_cc("punct" ++ Cs) -> {punct,Cs};
posix_cc("space" ++ Cs) -> {space,Cs};
posix_cc("upper" ++ Cs) -> {upper,Cs};
posix_cc("xdigit" ++ Cs) -> {xdigit,Cs};
posix_cc(Cs) -> parse_error({posix_cc,substr(Cs, 1, 5)}).

%% special_char(Char) -> bool().
%% These are the special characters for an ERE.
%% N.B. ]}) are only special in the context after [{(.

special_char($^) -> true;
special_char($.) -> true;
special_char($[) -> true;
special_char($$) -> true;
special_char($() -> true;
special_char($)) -> true;
special_char($|) -> true;
special_char($*) -> true;
special_char($+) -> true;
special_char($?) -> true;
special_char(${) -> true;
special_char($\\) -> true;
special_char(_) -> false.

escape_char([O1,O2,O3|S]) when
  O1 >= $0, O1 =< $7, O2 >= $0, O2 =< $7, O3 >= $0, O3 =< $7 ->
    {(O1*8 + O2)*8 + O3 - 73*$0,S};
escape_char([C|S]) -> {escape_char1(C),S};
escape_char([]) -> parse_error({unterminated,"\\"}).

escape_char1($n) -> $\n;			%\n = LF
escape_char1($r) -> $\r;			%\r = CR
escape_char1($t) -> $\t;			%\t = TAB
escape_char1($v) -> $\v;			%\v = VT
escape_char1($b) -> $\b;			%\b = BS
escape_char1($f) -> $\f;			%\f = FF
escape_char1($e) -> $\e;			%\e = ESC
escape_char1($s) -> $\s;			%\s = SPACE
escape_char1($d) -> $\d;			%\d = DEL
escape_char1(C) -> C.

%% interval_range(Chars) -> {Min,Max,RestChars}.
%% NoInt     -> none,none
%% Int       -> Int,none
%% Int,      -> Int,any
%% Int1,Int2 -> Int1,Int2

interval_range(Cs0) ->
    case number(Cs0) of
	{none,Cs1} -> {none,none,Cs1};
	{N,[$,|Cs1]} ->
	    case number(Cs1) of
		{none,Cs2} -> {N,any,Cs2};
		{M,Cs2} -> {N,M,Cs2}
	    end;
	{N,Cs1} -> {N,none,Cs1}
    end.

number([C|Cs]) when C >= $0, C =< $9 ->
    number(Cs, C - $0);
number(Cs) -> {none,Cs}.

number([C|Cs], Acc) when C >= $0, C =< $9 ->
    number(Cs, 10*Acc + (C - $0));
number(Cs, Acc) -> {Acc,Cs}.

parse_error(E) -> throw({error,E}).

string_between(Cs1, Cs2) ->
    substr(Cs1, 1, length(Cs1)-length(Cs2)).

%% NFA states
%% State type defines type of transition from the state.
%% N.B. all types have the id in the same field and all types except
%% estate have the next state pointer in the same field. These are
%% invariants and are used in the code!

-record(cstate, {id,c,s}).			%Character state
-record(nstate, {id,cc,s}).			%Character class state
-record(estate, {id,s1,s2}).			%Epsilon state
-record(lstate, {id,n,s}).			%Parentheses states
-record(rstate, {id,n,s}).
-record(pstate, {id,t,s}).			%Position states
-record(astate, {id,t,s}).			%Accept state

%% comp({Regexp,SubCount}, Flags) -> {ok,#nfa{}} | {error,Error}.
%% Compile a (parsed) regexp into an NFA.
%%
%% This is basically Thompson's algorithm but we create fewer epsilon
%% states which is more efficient when we interpret the NFA.

-record(thom, {n,s,fl}).			%Next state, next sub, flags

comp({RE,Sc}, Fl) ->
    St0 = #thom{n=1,s=1,fl=Fl},
    {F,Nfa0,St1} = comp(RE, [], St0),
    N = St1#thom.n,
    Nfa1 = [#astate{id=N}|Nfa0],		%Add final accept state.
    {{Start,_},Nfa2,St2} = concat(F, {N,[N]}, Nfa1, St1#thom{n=N+1}),
    {ok,#nfa{cflags=Fl,
	     nfa=list_to_tuple(keysort(#nstate.id, Nfa2)),
	     start=Start,
	     nsub=St2#thom.s-1}}.

comp({alt,[A|As]}, Nfa, St) ->
    foldl(fun (E, {Lf,Nfa0,St0}) ->
		  {Ef,Nfa1,St1} = comp(E, Nfa0, St0),
		  alt(Lf, Ef, Nfa1, St1)
	  end, comp(A, Nfa, St), As);
comp({seq,[S|Ss]}, Nfa, St) ->
    foldl(fun (E, {Lf,Nfa0,St0}) ->
		  {Ef,Nfa1,St1} = comp(E, Nfa0, St0),
		  concat(Lf, Ef, Nfa1, St1)
	  end, comp(S, Nfa, St), Ss);
comp({kclosure,R}, Nfa0, St0) ->
    {F,Nfa1,St1} = comp(R, Nfa0, St0),
    kclosure(F, Nfa1, St1);
comp({pclosure,R}, Nfa0, St0) ->
    {F,Nfa1,St1} = comp(R, Nfa0, St0),
    pclosure(F, Nfa1, St1);
comp({optional,R}, Nfa0, St0) ->
    {F,Nfa1,St1} = comp(R, Nfa0, St0),
    optional(F, Nfa1, St1);
comp({interval,R,Min,Max}, Nfa, St) ->
    comp_int(R, Min, Max, Nfa, St);
comp({sub,R,none}, Nfa, St) ->			%Unnumbered sub expr
    comp(R, Nfa, St);
comp({sub,R,_}, Nfa0, St0) ->
    case (St0#thom.fl)#cflags.sub of
	true ->
	    Sc = St0#thom.s,
	    {L,Nfa1,St1} = lparen(Sc, Nfa0, St0#thom{s=Sc+1}),
	    {F,Nfa2,St2} = comp(R, Nfa1, St1),
	    rparen(Sc, F, L, Nfa2, St2);
	false -> comp(R, Nfa0, St0)
    end;
comp(bos, Nfa, St) ->
    B = case (St#thom.fl)#cflags.newline of
	    true -> bol;
	    false -> bos
	end,
    pstate(B, Nfa, St);
comp(eos, Nfa, St) ->
    E = case (St#thom.fl)#cflags.newline of
	    true -> eol;
	    false -> eos
	end,
    pstate(E, Nfa, St);
comp(any, Nfa, St) ->
    Class = case (St#thom.fl)#cflags.newline of
		true -> [{0,9},{11,maxchar}];	%Any char but \n
		false -> [{0,maxchar}]		%POSIX any char
	    end,
    nstate(Class, Nfa, St);
comp({char_class,Cc}, Nfa, St) ->
    nstate(pack_cc(Cc), Nfa, St);
comp({comp_class,Cc}, Nfa, St) ->
    nstate(comp_cc(Cc), Nfa, St);
comp({lit,[C|Cs]}, Nfa, St) ->
    foldl(fun (C, {Lf,Nfa0,St0}) ->
		  {Cf,Nfa1,St1} = cstate(C, Nfa0, St0),
		  concat(Lf, Cf, Nfa1, St1)
	  end, cstate(C, Nfa, St), Cs);
comp(epsilon, Nfa, St) -> {epsilon,Nfa,St}.

%% comp_int(RegExp, Min, Max, Nfa, CompState) -> {Frame,Nfa,CompState}.
%%  Compile an interval into a new frame and an updated NFA. Do this
%%  by simply transforming it into corresponding sequence of regexps
%%  and optionals.

comp_int(_, 0, 0, Nfa, St) -> {epsilon,Nfa,St};
comp_int(_, 0, none, Nfa, St) -> {epsilon,Nfa,St};
comp_int(R, 0, any, Nfa, St) -> comp({kclosure,R}, Nfa, St);
comp_int(R, Min, any, Nfa, St) ->
    comp({seq,duplicate(Min, R) ++ [{kclosure,R}]}, Nfa, St);
comp_int(R, Min, none, Nfa, St) ->
    comp({seq,duplicate(Min, R)}, Nfa, St);
comp_int(R, Min, Min, Nfa, St) when is_integer(Min) ->
    comp({seq,duplicate(Min, R)}, Nfa, St);
comp_int(R, Min, Max, Nfa, St) ->
    Rs = duplicate(Min, R),
    Os = duplicate(Max-Min, {optional,R}),	%Optional part
    comp({seq,Rs ++ Os}, Nfa, St).

%% lparen(SubCount, Nfa, NextState) -> {Frame,Nfa,NextState}.
%% rparen(SubCount, SubFrame, LeftFrame, Nfa, NextState) ->
%%      {Frame,Nfa,NextState}.
%%  Compile the left/right parentheses which add states. Add states
%%  even if the sub-expr is empty as this is a valid result.

lparen(Sc, Nfa0, St) ->
    N = St#thom.n,
    Nfa1 = [#lstate{id=N,n=Sc}|Nfa0],
    {{N,[N]},Nfa1,St#thom{n=N+1}}.

rparen(Sc, epsilon, {Lb,Les}, Nfa0, St) ->
    N = St#thom.n,
    Nfa1 = patch(Nfa0, Les, N),
    Nfa2 = [#rstate{id=N,n=Sc}|Nfa1],
    {{Lb,[N]},Nfa2,St#thom{n=N+1}};
rparen(Sc, {B,Es}, {Lb,Les}, Nfa0, St) ->
    N = St#thom.n,
    Nfa1 = patch(Nfa0, Les, B),
    Nfa2 = [#rstate{id=N,n=Sc}|Nfa1],
    Nfa3 = patch(Nfa2, Es, N),
    {{Lb,[N]},Nfa3,St#thom{n=N+1}}.

%% kclosure(Frame, Nfa, CompState) -> {Frame,Nfa,CompState}.
%% pclosure(Frame, Nfa, CompState) -> {Frame,Nfa,CompState}.
%% optional(Frame, Nfa, CompState) -> {Frame,Nfa,CompState}.
%%  Compile standard repeat operators.

kclosure(epsilon, Nfa, St) -> {epsilon,Nfa,St};
kclosure({B,Es}, Nfa0, St) ->
    N = St#thom.n,
    Nfa1 = [#estate{id=N,s1=B,s2=none}|Nfa0],
    {{N,[N]},patch(Nfa1, Es, N),St#thom{n=N+1}}.

pclosure(epsilon, Nfa, St) -> {epsilon,Nfa,St};
pclosure({B,Es}, Nfa0, St) ->
    N = St#thom.n,
    Nfa1 = [#estate{id=N,s1=B,s2=none}|Nfa0],
    {{B,[N]},patch(Nfa1, Es, N),St#thom{n=N+1}}.

optional(epsilon, Nfa, St) -> {epsilon,Nfa,St};
optional({B,Es}, Nfa0, St) ->
    N = St#thom.n,
    Nfa1 = [#estate{id=N,s1=B,s2=none}|Nfa0],
    {{N,Es ++ [N]},Nfa1,St#thom{n=N+1}}.

%% cstate(Char, Nfa, CompState) -> {Frame,Nfa,CompState}.
%% nstate(Class, Nfa, CompState) -> {Frame,Nfa,CompState}.
%% pstate(Type, Nfa, CompState) -> {Frame,Nfa,CompState}.
%%  Basic states for char, class and transition.

cstate(C, Nfa0, St) ->
    N = St#thom.n,
    Nfa1 = [#cstate{id=N,c=C}|Nfa0],
    {{N,[N]},Nfa1,St#thom{n=N+1}}.

nstate(Cc, Nfa0, St) ->
    N = St#thom.n,
    Nfa1 = [#nstate{id=N,cc=Cc}|Nfa0],
    {{N,[N]},Nfa1,St#thom{n=N+1}}.

pstate(Type, Nfa0, St) ->
    N = St#thom.n,
    Nfa1 = [#pstate{id=N,t=Type}|Nfa0],
    {{N,[N]},Nfa1,St#thom{n=N+1}}.

%% concat(Frame1, Fram2, Nfa, CompState) -> {Frame,Nfa,CompState}.

concat(epsilon, F2, Nfa, St) -> {F2,Nfa,St};
concat(F1, epsilon, Nfa, St) -> {F1,Nfa,St};
concat({B1,Es1}, {B2,Es2}, Nfa0, St) ->
    Nfa1 = patch(Nfa0, Es1, B2),
    {{B1,Es2},Nfa1,St}.

%% alt(Frame1, Fram2, Nfa, CompState) -> {Frame,Nfa,CompState}.

alt(epsilon, {B2,E2}, Nfa0, St) ->
    N = St#thom.n,
    Nfa1 = [#estate{id=N,s1=none,s2=B2}|Nfa0],
    {{N,[N|E2]},Nfa1,St#thom{n=N+1}};
alt({B1,E1}, epsilon, Nfa0, St) ->
    N = St#thom.n,
    Nfa1 = [#estate{id=N,s1=B1,s2=none}|Nfa0],
    {{N,E1 ++ [N]},Nfa1,St#thom{n=N+1}};
alt({B1,E1}, {B2,E2}, Nfa0, St) ->
    N = St#thom.n,
    Nfa1 = [#estate{id=N,s1=B1,s2=B2}|Nfa0],
    {{N,E1 ++ E2},Nfa1,St#thom{n=N+1}}.

%% patch(NFA, EndStates, Beginning) -> NFA.
%%  Patch Endstates so they all point to Beginning.

patch(Nfa, Es, B) ->
    foldl(fun (E, Nfa0) -> patch1(Nfa0, E, B) end, Nfa, Es).

patch1([#cstate{id=E}=Nst|Nfa], E, B) ->
    [Nst#cstate{s=B}|Nfa];
patch1([#nstate{id=E}=Nst|Nfa], E, B) ->
    [Nst#nstate{s=B}|Nfa];
%% Patch empty slot(s) of estate.
patch1([#estate{id=E,s1=none,s2=none}=Nst|Nfa], E, B) ->
    [Nst#estate{s1=B,s2=B}|Nfa];		%Effectively removes it.
patch1([#estate{id=E,s1=none}=Nst|Nfa], E, B) ->
    [Nst#estate{s1=B}|Nfa];
patch1([#estate{id=E,s2=none}=Nst|Nfa], E, B) ->
    [Nst#estate{s2=B}|Nfa];
patch1([#lstate{id=E}=Nst|Nfa], E, B) ->
    [Nst#lstate{s=B}|Nfa];
patch1([#rstate{id=E}=Nst|Nfa], E, B) ->
    [Nst#rstate{s=B}|Nfa];
patch1([#pstate{id=E}=Nst|Nfa], E, B) ->
    [Nst#pstate{s=B}|Nfa];
patch1([Nst|Nfa], E, B) ->
    [Nst|patch1(Nfa, E, B)].

comp_cc(Cc) -> comp_class(pack_cc(Cc), 0).

comp_class([{C1,C2}|Crs], Last) ->
    [{Last,C1-1}|comp_class(Crs, C2+1)];
comp_class([C|Crs], Last) when Last == C-1 ->
    [Last|comp_class(Crs, C+1)];
comp_class([C|Crs], Last) when is_integer(C) ->
    [{Last,C-1}|comp_class(Crs, C+1)];
comp_class([], Last) -> [{Last,maxchar}].

%% comp_posix(Posix, CharClass) -> CharClass.
%%  Handle POSIX character classes, use Latin-1 character set.

comp_posix(alnum, Cc) -> comp_posix(alpha, comp_posix(digit, Cc));
comp_posix(alpha, Cc) -> comp_posix(upper, comp_posix(lower, Cc));
comp_posix(blank, Cc) -> [$\s,$\t,160|Cc];
comp_posix(cntrl, Cc) -> [{0,31},{127,159}|Cc];
comp_posix(digit, Cc) -> [{$0,$9}|Cc];
comp_posix(graph, Cc) -> [{33,126},{161,255}|Cc];
comp_posix(lower, Cc) -> [{$a,$z},{$à,$ö},{$ø,$ÿ}|Cc];
comp_posix(print, Cc) -> [{32,126},{160,255}|Cc];
comp_posix(punct, Cc) -> [{$!,$/},{$:,$?},{${,$~},{161,191}|Cc];
comp_posix(space, Cc) -> [$\s,$\t,$\f,$\r,$\v,160|Cc];
comp_posix(upper, Cc) -> [{$A,$Z},{$À,$Ö},{$Ø,$ß}|Cc];
comp_posix(xdigit, Cc) -> [{$a,$f},{$A,$F},{$0,$9}|Cc].

%% pack_cc(CharClass) -> CharClass
%%  Pack and optimise a character class specification (bracket
%%  expression). First sort it and then compact it.

pack_cc(Cc0) ->
    %% First expand the posix classes and remove range tag ...
    Cc1 = foldl(fun ({posix,Pcl}, Cc) -> comp_posix(Pcl, Cc);
		    ({range,Cf,Cl}, Cc) -> [{Cf,Cl}|Cc];
		    (C, Cc) -> [C|Cc]
		end, [], Cc0),
    %% then sort the list ...
    Cc2 = usort(fun ({Cf1,_}, {Cf2,_}) -> Cf1 < Cf2;
		    ({Cf1,_}, C) -> Cf1 < C;
		    (C, {Cf,_}) -> C < Cf;
		    (C1, C2) -> C1 =< C2
		end, Cc1),
    %% then compact it.
    pack_cc1(Cc2).

pack_cc1([{Cf1,Cl1},{Cf2,Cl2}|Cc]) when Cl1 >= Cf2, Cl1 =< Cl2 ->
    %% Cf1       Cl1
    %%     Cf2       Cl2
    pack_cc1([{Cf1,Cl2}|Cc]);
pack_cc1([{Cf1,Cl1},{Cf2,Cl2}|Cc]) when Cl1 >= Cf2, Cl1 >= Cl2 ->
    %% Cf1       Cl1
    %%     Cf2 Cl2
    pack_cc1([{Cf1,Cl1}|Cc]);
pack_cc1([{Cf1,Cl1},{Cf2,Cl2}|Cc]) when Cl1+1 == Cf2 ->
    %% Cf1    Cl1
    %%           Cf2   Cl2
    pack_cc1([{Cf1,Cl2}|Cc]);
pack_cc1([{Cf,Cl},C|Cc]) when Cl >= C -> pack_cc1([{Cf,Cl}|Cc]);
pack_cc1([{Cf,Cl},C|Cc]) when Cl+1 == C -> pack_cc1([{Cf,C}|Cc]);
pack_cc1([C,{Cf,Cl}|Cc]) when C == Cf-1 -> pack_cc1([{C,Cl}|Cc]);
pack_cc1([C1,C2|Cc]) when C1+1 == C2 -> pack_cc1([{C1,C2}|Cc]);
pack_cc1([C|Cc]) -> [C|pack_cc1(Cc)];
pack_cc1([]) -> [].

%% parse_cflags(Flags) -> FlagsRec.
%% parse_cflags(Flags, FlagsRec) -> FlagsRec.
%%  Parse the flags and set the flag record.

parse_cflags(Fs) ->
    parse_cflags(Fs, #cflags{ignore_case=false,newline=false,sub=false}).

parse_cflags([{ignore_case,A}|Fs], F) when A == true ; A == false ->
    parse_cflags(Fs, F#cflags{ignore_case=A});
parse_cflags([{newline,A}|Fs], F) when A == true ; A == false ->
    parse_cflags(Fs, F#cflags{newline=A});
parse_cflags([{subexpr,S}|Fs], F) when S == true ; S == false ->
    parse_cflags(Fs, F#cflags{sub=S});
parse_cflags([], F) -> F.

%% The interface functions.

%% sh_to_awk(ShellRegExp)
%%  Convert a sh style regexp into a full AWK one. The main difficulty is
%%  getting character sets right as the conventions are different.

sh_to_awk(Sh) -> "^(" ++ sh_to_awk_1(Sh).	%Fix the beginning

sh_to_awk_1([$*|Sh]) ->				%This matches any string
    ".*" ++ sh_to_awk_1(Sh);
sh_to_awk_1([$?|Sh]) ->				%This matches any character
    [$.|sh_to_awk_1(Sh)];
sh_to_awk_1([$[,$^,$]|Sh]) ->			%This takes careful handling
    "\\^" ++ sh_to_awk_1(Sh);
%% Must move '^' to end.
sh_to_awk_1("[^" ++ Sh) -> [$[|sh_to_awk_2(Sh, true)];
sh_to_awk_1("[!" ++ Sh) -> "[^" ++ sh_to_awk_2(Sh, false);
sh_to_awk_1([$[|Sh]) -> [$[|sh_to_awk_2(Sh, false)];
sh_to_awk_1([C|Sh]) ->
    %% Unspecialise everything else which is not an escape character.
    case sh_special_char(C) of
	true -> [$\\,C|sh_to_awk_1(Sh)];
	false -> [C|sh_to_awk_1(Sh)]
    end;
sh_to_awk_1([]) -> ")$".			%Fix the end

sh_to_awk_2([$]|Sh], UpArrow) -> [$]|sh_to_awk_3(Sh, UpArrow)];
sh_to_awk_2(Sh, UpArrow) -> sh_to_awk_3(Sh, UpArrow).

sh_to_awk_3([$]|Sh], true) -> "^]" ++ sh_to_awk_1(Sh);
sh_to_awk_3([$]|Sh], false) -> [$]|sh_to_awk_1(Sh)];
sh_to_awk_3([C|Sh], UpArrow) -> [C|sh_to_awk_3(Sh, UpArrow)];
sh_to_awk_3([], true) -> [$^|sh_to_awk_1([])];
sh_to_awk_3([], false) -> sh_to_awk_1([]).

%% sh_special_char(Char) -> bool().
%%  Test if a character is a special character. Add ]}) and " as
%%  specials here.

sh_special_char($)) -> true;
sh_special_char($]) -> true;
sh_special_char($}) -> true;
sh_special_char($") -> true;
sh_special_char(C) -> special_char(C).

%% parse(String) -> {ok,RegExp} | {error,Error}.
%%  Parse a regular expression string. No flags affect the parsing.

parse(Cs) -> parse1(Cs, parse_cflags([])).	%Default flags

parse1(Cs, _) ->				%Flags not used here!
    case catch reg(Cs) of
	{ok,R,[]} -> {ok,{regexp,R}};
	{ok,_R,[C|_]} -> {error,{illegal,[C]}};
	{error,E} -> {error,E}
    end.

%% compile(String | RegExp) -> {ok,Nfa} | {error,Error}.
%% compile(String | RegExp | NFA, Flags) -> {ok,Nfa} | {error,Error}.
%%  Compile the regular expression to an NFA. If the regexp aleady is
%%  compiled then this is an identity op.

compile(RE) -> compile(RE, []).			%Default flags
compile(RE, Fls) -> compile1(RE, parse_cflags(Fls)).

compile1(Cs, Fl) when is_list(Cs) ->
    case parse1(Cs, Fl) of
	{ok,R} -> compile1(R, Fl);
	Error -> Error
    end;
compile1({regexp,R}, Fl) ->
    case comp(R, Fl) of
	{ok,Nfa} -> {ok,Nfa};
	Error -> Error
    end;
compile1(#nfa{}=N, _) -> {ok,N}.		%Use compile time flags

%% format_error(Error) -> String.

format_error({interval_range,What}) ->
    ["illegal interval range",io_lib:write_string(What)];
format_error({illegal_char,What}) -> ["illegal character `",What,"'"];
format_error({unterminated,What}) -> ["unterminated `",What,"'"];
format_error({posix_cc,What}) ->
    ["illegal POSIX character class ",io_lib:write_string(What)];
format_error({char_class,What}) ->
    ["illegal character class ",io_lib:write_string(What)].

%% match(String, RegExp) -> {match,Start,Length} | nomatch | {error,E}.
%% match(String, RegExp, Flags) ->
%%      {match,Start,Length} | nomatch | {error,E}.
%%  Find the longest first match of RegExp in String, return Start and
%%  Length. N.B. If the regular expression is already compiled then
%%  the flags used when compiling are used here.

match(S, RegExp) -> match(S, RegExp, []).	%Default flags
match(S, RegExp, Fls) -> match1(S, RegExp, parse_cflags(Fls)).

match1(S, RegExp, Fl) ->
    case compile1(RegExp, Fl) of
	{ok,Nfa} when is_binary(S) ->
	    %% Match against a binary.
	    match_bin(S, Nfa, Fl);
	{ok,Nfa} ->
	    %% Match against a string.
	    match_str(S, Nfa, Fl);
	Error -> Error
    end.

match_str(Cs, #nfa{cflags=Fl}=Nfa, _) ->
    case Fl#cflags.sub of
	true -> smatch_str(Cs, 1, bos, Nfa);
	false -> match_str(Cs, 1, bos, Nfa)
    end.

match_str(Cs0, P, Pc, Nfa) ->
    case next_match_str(Cs0, P, Pc, Nfa) of
	{match,St,Len,Cs,_,_} -> {match,{St,Len,substr(Cs, 1, Len)}};
	nomatch -> nomatch
    end.

smatch_str(Cs0, P, Pc, Nfa) ->
    case next_smatch_str(Cs0, P, Pc, Nfa) of
	{match,St,Len,Cs,_,Subs,_} ->
	    {match,{St,Len,substr(Cs, 1, Len)},fix_subs_str(Subs, St, Cs)};
	nomatch -> nomatch
    end.

match_bin(Bin, #nfa{cflags=Fl}=Nfa, _) ->
    case Fl#cflags.sub of
	true -> smatch_bin(Bin, 1, bos, Nfa);
	false -> match_bin(Bin, 1, bos, Nfa)
    end.

match_bin(Bin, P, Pc, Nfa) ->
    case next_match_bin(Bin, P, Pc, Nfa) of
	{match,St,Len,_} -> {match,{St,Len,bin_to_list(Bin, St, Len)}};
	nomatch -> nomatch
    end.

smatch_bin(Bin, P, Pc, Nfa) ->
    case next_smatch_bin(Bin, P, Pc, Nfa) of
	{match,St,Len,_,Subs} ->
	    {match,{St,Len,bin_to_list(Bin, St, Len)},fix_subs_bin(Subs, Bin)};
	nomatch -> nomatch
    end.

%% best_match(String, RegExp) -> {match,Start,Length} | nomatch | {error,E}.
%% best_match(String, RegExp, Flags) ->
%%      {match,Start,Length} | nomatch | {error,E}.
%%  Find the first longest match of RegExp in String.

best_match(S, RegExp) -> best_match(S, RegExp, []). %Default flags
best_match(S, RegExp, Fls) -> best_match1(S, RegExp, parse_cflags(Fls)).

best_match1(S, RegExp, Fl) ->
    case compile1(RegExp, Fl) of
	{ok,Nfa} when is_binary(S) ->
	    %% Match against a binary.
	    best_match_bin(S, Nfa, Fl);
	{ok,Nfa} ->
	    %% Match against a string.
	    best_match_str(S, Nfa, Fl);
	Error -> Error
    end.

best_match_str(Cs, #nfa{cflags=Fl}=Nfa, _) ->
    case Fl#cflags.sub of
	true -> best_smatch_str(Cs, 1, bos, Nfa);
	false -> best_match_str(Cs, 1, bos, Nfa)
    end.

best_match_str(Cs0, P, Pc, Nfa) ->
    case best_match_str(Cs0, P, Pc, Nfa, {0,-1,[]}) of
	{St,Len,Cs1} when Len >= 0 ->
	    {match,{St,Len,substr(Cs1, 1, Len)}};
	{_,_} -> nomatch
    end.

best_match_str(Cs0, P, Pc0, Nfa, {_,Mlen,_}=M) ->
    case next_match_str(Cs0, P, Pc0, Nfa) of
	{match,St,Len,[Pc1|Cs]=Cs1,_,_} ->
	    if Len > Mlen -> best_match_str(Cs, St+1, Pc1, Nfa, {St,Len,Cs1});
	       true -> best_match_str(Cs, St+1, Pc1, Nfa, M)
	    end;
	{match,St,Len,[],_,_} ->		%Empty match at end
	    if Len > Mlen -> {St,Len,[]};
	       true -> M
	    end;
	nomatch -> M
    end.

best_smatch_str(Cs0, P, Pc, Nfa) ->
    case best_smatch_str(Cs0, P, Pc, Nfa, {0,-1,[],none}) of
	{St,Len,Cs1,Subs} when Len >= 0 ->
	    {match,{St,Len,substr(Cs1, 1, Len)},fix_subs_str(Subs, St, Cs1)};
	{_,_} -> nomatch
    end.

best_smatch_str(Cs0, P, Pc0, Nfa, {_,Mlen,_,_}=M) ->
    case next_smatch_str(Cs0, P, Pc0, Nfa) of
	{match,St,Len,[Pc1|Cs]=Cs1,_,Subs,_} ->		%Found a match
	    if Len > Mlen ->
		    best_smatch_str(Cs, St+1, Pc1, Nfa, {St,Len,Cs1,Subs});
	       true -> best_smatch_str(Cs, St+1, Pc1, Nfa, M)
	    end;
	{match,St,Len,[],_,Subs,_} ->
	    if Len > Mlen -> {St,Len,[],Subs};
	       true -> M
	    end;
	nomatch -> M
    end.

best_match_bin(Bin, #nfa{cflags=Fl}=Nfa, _) ->
    case Fl#cflags.sub of
	true -> best_smatch_bin(Bin, 1, bos, Nfa);
	false -> best_match_bin(Bin, 1, bos, Nfa)
    end.

best_match_bin(Bin, P, Pc, Nfa) ->
    case best_match_bin(Bin, P, Pc, Nfa, {0,-1}) of
	{St,Len} when Len >= 0 ->
	    {match,{St,Len,bin_to_list(Bin, St, Len)}};
	{_,_} -> nomatch
    end.

best_match_bin(Bin, P, Pc0, Nfa, {_,Mlen}=M) ->
    case next_match_bin(Bin, P, Pc0, Nfa) of
	{match,St,Len,_} when St+Len >= size(Bin) ->
	    if Len > Mlen -> {St,Len};
	       true -> M
	    end;
	{match,St,Len,_} ->
	    if Len > Mlen ->
		    best_match_bin(Bin, St+1, unknown, Nfa, {St,Len});
	       true -> best_match_bin(Bin, St+1, unknown, Nfa, M)
	    end;
	nomatch -> M
    end.

best_smatch_bin(Bin, P, Pc, Nfa) ->
    case best_smatch_bin(Bin, P, Pc, Nfa, {0,-1,none}) of
	{St,Len,Subs} when Len >= 0 ->
	    {match,{St,Len,bin_to_list(Bin, St, Len)},
	     fix_subs_bin(Subs, Bin)};
	{_,_} -> nomatch
    end.

best_smatch_bin(Bin, P, Pc0, Nfa, {_,Mlen,_}=M) ->
    case next_smatch_bin(Bin, P, Pc0, Nfa) of
	{match,St,Len,_,Subs} when St+Len == size(Bin) ->
	    if Len > Mlen -> {St,Len,Subs};
	       true -> M
	    end;
	{match,St,Len,_,Subs} ->
	    if Len > Mlen ->
		    best_smatch_bin(Bin, St+1, unknown, Nfa, {St,Len,Subs});
	       true -> best_smatch_bin(Bin, St+1, unknown, Nfa, M)
	    end;
	nomatch -> M
    end.

%% matches(String, RegExp) -> {match,[{Start,Length}]} | {error,E}.
%% matches(String, RegExp, Flags) -> {match,[{Start,Length}]} | {error,E}.
%%  Return the all the non-overlapping matches of RegExp in String.

matches(S, RegExp) -> matches(S, RegExp, []).	%Default flags
matches(S, RegExp, Fls) -> matches1(S, RegExp, parse_cflags(Fls)).

matches1(S, RegExp, Fl) ->
    case compile1(RegExp, Fl) of
	{ok,Nfa} when is_binary(S) ->
	    %% Match against a binary.
	    matches_bin(S, Nfa, Fl);
	{ok,Nfa} ->
	    %% Match against a string.
	    matches_str(S, Nfa, Fl);
	Error -> Error
    end.

matches_str(Cs, #nfa{cflags=Fl}=Nfa, _) ->
    case Fl#cflags.sub of
	true -> {match,smatches_str(Cs, 1, bos, Nfa)};
	false -> {match,matches_str(Cs, 1, bos, Nfa)}
    end.

matches_str(Cs0, P0, Pc0, Nfa) ->
    case next_match_str(Cs0, P0, Pc0, Nfa) of
	%% Handle zero length match specially to make sure we go on!
	{match,St,0,_,_,[Pc1|Cs1]} ->
	    [{St,0,[]}|matches_str(Cs1, St+1, Pc1, Nfa)];
	{match,St,0,_,_,[]} -> [{St,0,[]}];
	{match,St,Len,Cs,Pc1,Cs1} ->
	    [{St,Len,substr(Cs, 1, Len)}|matches_str(Cs1, St+Len, Pc1, Nfa)];
	nomatch -> []
    end.

smatches_str(Cs0, P0, Pc0, Nfa) ->
    case next_smatch_str(Cs0, P0, Pc0, Nfa) of
	%% Handle zero length match specially to make sure we go on!
	{match,St,0,_,_,Subs,[Pc1|Cs1]} ->
	    [{St,0,[],fix_subs_str(Subs, St, [])}|
	     smatches_str(Cs1, St+1, Pc1, Nfa)];
	{match,St,0,_,_,Subs,[]} -> [{St,0,[],fix_subs_str(Subs, St, [])}];
	{match,St,Len,Cs,Pc1,Subs,Cs1} ->
	    [{St,Len,substr(Cs, 1, Len),fix_subs_str(Subs, St, Cs)}|
	     smatches_str(Cs1, St+Len, Pc1, Nfa)];
	nomatch -> []
    end.

matches_bin(Bin, #nfa{cflags=Fl}=Nfa, _) ->
    case Fl#cflags.sub of
	true -> {match,smatches_bin(Bin, 1, bos, Nfa)};
	false -> {match,matches_bin(Bin, 1, bos, Nfa)}
    end.

matches_bin(Bin, P0, Pc0, Nfa) ->
    case next_match_bin(Bin, P0, Pc0, Nfa) of
	%% Handle zero length match specially to make sure we go on!
	{match,St,0,_} when St =< size(Bin) ->
	    [{St,0,[]}|matches_bin(Bin, St+1, unknown, Nfa)];
	{match,St,0,_} -> [{St,0,[]}];
	{match,St,Len,Pc1} ->
	    [{St,Len,bin_to_list(Bin, St, Len)}|
	     matches_bin(Bin, St+Len, Pc1, Nfa)];
	nomatch -> []
    end.

smatches_bin(Bin, P0, Pc0, Nfa) ->
    case next_smatch_bin(Bin, P0, Pc0, Nfa) of
	%% Handle zero length match specially to make sure we go on!
	{match,St,0,_,Subs} when St =< size(Bin) ->
	    [{St,0,[],fix_subs_bin(Subs, Bin)}|
	     smatches_bin(Bin, St+1, unknown, Nfa)];
	{match,St,0,_,Subs} -> [{St,0,[],fix_subs_bin(Subs, Bin)}];
	{match,St,Len,Pc1,Subs} ->
	    [{St,Len,bin_to_list(Bin, St, Len),fix_subs_bin(Subs, Bin)}|
	      smatches_bin(Bin, St+Len, Pc1, Nfa)];
	nomatch -> []
    end.

%% sub(String, RegExp, Replace) -> {ok,RepString,RepCount} | {error,E}.
%% sub(String, RegExp, Replace, Flags) ->
%%      {ok,RepString,RepCount} | {error,E}.
%%  Substitute the first match of the regular expression RegExp with
%%  the string Replace in String. Accept pre-parsed regular
%%  expressions.

sub(S, RegExp, Rep) -> sub(S, RegExp, Rep, []).	%Default flags
sub(S, RegExp, Rep, Fls) -> sub1(S, RegExp, Rep, parse_cflags(Fls)).

sub1(S, RegExp, Rep, Fl) ->
    case compile1(RegExp, Fl) of
	{ok,Nfa} when is_binary(S) ->
	    %% Match against a binary.
	    sub_bin(S, Nfa, Rep, Fl);
	{ok,Nfa} ->
	    %% Match against a string.
	    sub_str(S, Nfa, Rep, Fl);
	Error -> Error
    end.

%% sub_str(String, NFA, Replacement, Flags) -> {yes,NewString} | no.
%% sub_bin(Binary, NFA, Replacement, Flags) -> {yes,NewString} | no.
%% Step forward over String until a match is found saving stepped over
%% chars in Before. Return reversed Before prepended to replacement
%% and rest of string.

sub_str(Cs, #nfa{cflags=Fl}=Nfa, Rep, _) ->
    Res = case Fl#cflags.sub of
	      true -> ssub_str(Cs, 1, bos, Nfa, Rep);
	      false -> sub_str(Cs, 1, bos, Nfa, Rep)
	  end,
    case Res of
	{yes,NewStr} -> {ok,NewStr,1};
	no -> {ok,Cs,0}
    end.

sub_str(Cs0, P, Pc, Nfa, Rep) ->
    case next_match_str(Cs0, P, Pc, Nfa) of
	{match,St,Len,Cs,_,Cs1} ->
	    {yes,substr_app(St-P, Cs0,
			    sub_repl(Rep, substr(Cs, 1, Len), Cs1))};
	nomatch -> no
    end.

substr_app(0, _, App) -> App;
substr_app(N, [C|Cs], App) ->
    [C|substr_app(N-1, Cs, App)];
substr_app(_, [], App) -> App.

sub_bin(Bin, #nfa{cflags=Fl}=Nfa, Rep, _) ->
    Res = case Fl#cflags.sub of
	      true -> ssub_bin(Bin, 1, bos, Nfa, Rep);
	      false -> sub_bin(Bin, 1, bos, Nfa, Rep)
	  end,
    case Res of
	{yes,NewBin} -> {ok,list_to_binary(NewBin),1};
	no -> {ok,Bin,0}
    end.

sub_bin(Bin, P, Pc, Nfa, Rep) ->
    case next_match_bin(Bin, P, Pc, Nfa) of
	{match,St,Len,_} ->
	    {yes,[sub_bin(Bin, P, St - P),
		  sub_repl(Rep, binary_to_list(Bin, St, St+Len-1),
			   sub_bin(Bin, St+Len))]};
	nomatch -> no
    end.

sub_repl(Rep, M, Rest) when is_function(Rep) ->
    Rep(M) ++ Rest;
sub_repl(Rep, M, Rest) -> sub_repl1(Rep, M, Rest).

sub_repl1([$&|Rep], M, Rest) -> M ++ sub_repl1(Rep, M, Rest);
sub_repl1([$\\,$&|Rep], M, Rest) -> [$&|sub_repl1(Rep, M, Rest)];
sub_repl1([C|Rep], M, Rest) -> [C|sub_repl1(Rep, M, Rest)];
sub_repl1([], _M, Rest) -> Rest.

%% ssub_str(String, Position, PrevC, NFA, Replacement) -> {yes,NewStr} | no.
%% ssub_bin(Binary, Position, PrevC, NFA, Replacement) -> {yes,NewBin} | no.
%% Step forward over String until a match is found saving stepped over
%% chars in Before. Return reversed Before prepended to replacement
%% and rest of string.

ssub_str(Cs0, P, Pc, Nfa, Rep) ->
    case next_smatch_str(Cs0, P, Pc, Nfa) of
	{match,St,Len,Cs,_,Subs0,Cs1} ->
	    Subs1 = fix_subs_str(Subs0, St, Cs),
	    {yes,substr_app(St-P, Cs0,
			    ssub_repl(Rep, substr(Cs, 1, Len), Subs1, Cs1))};
	nomatch -> no
    end.

ssub_bin(Bin, P, Pc, Nfa, Rep) ->
    case next_smatch_bin(Bin, P, Pc, Nfa) of
	{match,St,Len,_,Subs} ->
	    Subs1 = fix_subs_bin(Subs, Bin),
	    {yes,[sub_bin(Bin, P, St - P),
		  ssub_repl(Rep, binary_to_list(Bin, St, St+Len-1), Subs1,
			    sub_bin(Bin, St+Len))]};
	nomatch -> no
    end.

ssub_repl(Rep, M, Subs, Rest) when is_function(Rep) -> Rep(M, Subs) ++ Rest;
ssub_repl(Rep, M, Subs, Rest) -> ssub_repl1(Rep, M, Subs, Rest).

ssub_repl1([$&|Rep], M, Subs, Rest) -> M ++ ssub_repl1(Rep, M, Subs, Rest);
ssub_repl1([$\\,$&|Rep], M, Subs, Rest) -> [$&|ssub_repl1(Rep, M, Subs, Rest)];
ssub_repl1([$\\,C|Rep], M, Subs, Rest) when C >= $1, C =< $9 ->
    {_,_,S} = element(C - $0, Subs),
    S ++ ssub_repl1(Rep, M, Subs, Rest);
ssub_repl1([C|Rep], M, Subs, Rest) -> [C|ssub_repl1(Rep, M, Subs, Rest)];
ssub_repl1([], _, _, Rest) -> Rest.

%%  gsub(String, RegExp, Replace) -> {ok,RepString,RepCount} | {error,E}.
%%  gsub(String, RegExp, Replace, Flags) ->
%%      {ok,RepString,RepCount} | {error,E}.
%%  Substitute every match of the regular expression RegExp with the
%%  string New in String. Accept pre-parsed regular expressions.

gsub(S, RegExp, Rep) -> gsub(S, RegExp, Rep, []). %Default flags
gsub(S, RegExp, Rep, Fls) -> gsub1(S, RegExp, Rep, parse_cflags(Fls)).


gsub1(S, RegExp, Rep, Fl) ->
    case compile1(RegExp, Fl) of
	{ok,Nfa} when is_binary(S) ->
	    %% Match against a binary.
	    gsub_bin(S, Nfa, Rep, Fl);
	{ok,Nfa} ->
	    %% Match against a string.
	    gsub_str(S, Nfa, Rep, Fl);
	Error -> Error
    end.

gsub_str(Cs, #nfa{cflags=Fl}=Nfa, Rep, _) ->
    Res = case Fl#cflags.sub of
	      true -> gssub_str(Cs, 1, bos, Nfa, Rep);
	      false -> gsub_str(Cs, 1, bos, Nfa, Rep)
	  end,
    case Res of
	{NewStr,N} -> {ok,NewStr,N};
	no -> {ok,Cs,0}
    end.

gsub_str(Cs0, P, Pc0, Nfa, Rep) ->
    case next_match_str(Cs0, P, Pc0, Nfa) of
	%% Handle zero length match specially to make sure we go on!
	{match,St,0,_,_,[C|Cs1]} ->
	    {New,N} = gsub_str(Cs1, St+1, C, Nfa, Rep),
	    {substr_app(St-P, Cs0, sub_repl(Rep, [], [C|New])),N+1};
	{match,_,0,_,_,[]} -> {sub_repl(Rep, [], []),1};
	{match,St,Len,Cs,Pc1,Cs1} ->
	    {New,N} = gsub_str(Cs1, St+Len, Pc1, Nfa, Rep),
	    {substr_app(St-P, Cs0,
			sub_repl(Rep, substr(Cs, 1, Len), New)),N+1};
	nomatch -> {Cs0,0}
    end.

gssub_str(Cs0, P, Pc0, Nfa, Rep) ->
    case next_smatch_str(Cs0, P, Pc0, Nfa) of
	%% Handle zero length match specially to make sure we go on!
	{match,St,0,Cs,_,Subs0,[C|Cs1]} ->
	    {New,N} = gssub_str(Cs1, St+1, C, Nfa, Rep),
	    Subs1 = fix_subs_str(Subs0, St, Cs),
	    {substr_app(St-P, Cs0, ssub_repl(Rep, [], Subs1, [C|New])),N+1};
	{match,St,0,Cs,_,Subs0,[]} ->
	    Subs1 = fix_subs_str(Subs0, St, Cs),
	    {ssub_repl(Rep, [], Subs1, []),1};
	{match,St,Len,Cs,Pc1,Subs0,Cs1} ->
	    {New,N} = gssub_str(Cs1, St+Len, Pc1, Nfa, Rep),
	    Subs1 = fix_subs_str(Subs0, St, Cs),
	    {substr_app(St-P, Cs0,
			ssub_repl(Rep, substr(Cs, 1, Len), Subs1, New)),N+1};
	nomatch -> {Cs0,0}
    end.

gsub_bin(Bin, #nfa{cflags=Fl}=Nfa, Rep, _) ->
    Res = case Fl#cflags.sub of
	      true -> gssub_bin(Bin, 1, bos, Nfa, Rep);
	      false -> gsub_bin(Bin, 1, bos, Nfa, Rep)
	  end,
    case Res of
	{NewStr,N} -> {ok,list_to_binary(NewStr),N};
	no -> {ok,Bin,0}
    end.

gsub_bin(Bin, P, Pc0, Nfa, Rep) ->
    case next_match_bin(Bin, P, Pc0, Nfa) of
	{match,St,0,_} when St =< size(Bin) ->
	    {New,N} = gsub_bin(Bin, St+1, unknown, Nfa, Rep),
	    New1 = binary_to_list(Bin, St, St) ++ New,
	    {[sub_bin(Bin, P, St - P), sub_repl(Rep, [], New1)],N+1};
	{match,_,0,_} -> {sub_repl(Rep, [], []),1};
	{match,St,Len,Pc1} ->
	    {New,N} = gsub_bin(Bin, St+Len, Pc1, Nfa, Rep),
	    {[sub_bin(Bin, P, St - P),
	      sub_repl(Rep, binary_to_list(Bin, St, St+Len-1), New)], N+1};
	nomatch -> {sub_bin(Bin, P),0}
    end.

gssub_bin(Bin, P, Pc0, Nfa, Rep) ->
    case next_smatch_bin(Bin, P, Pc0, Nfa) of
	{match,St,0,Pc1,Subs0} when St =< size(Bin) ->
	    {New,N} = gssub_bin(Bin, St+1, Pc1, Nfa, Rep),
	    New1 = [binary_to_list(Bin, St, St)|New], %Step over 1 character
	    Subs1 = fix_subs_bin(Subs0, Bin),
	    {[sub_bin(Bin, P, St - P), ssub_repl(Rep, [], Subs1, New1)],N+1};
	{match,_,0,_,Subs0} ->
	    Subs1 = fix_subs_bin(Subs0, Bin),
	    {ssub_repl(Rep, [], Subs1, []),1};
	{match,St,Len,Pc1,Subs0} ->
	    {New,N} = gssub_bin(Bin, St+Len, Pc1, Nfa, Rep),
	    Subs1 = fix_subs_bin(Subs0, Bin),
	    {[sub_bin(Bin, P, St - P),
	      ssub_repl(Rep, binary_to_list(Bin, St, St+Len-1), Subs1, New)], N+1};
	nomatch -> {sub_bin(Bin, P),0}
    end.

%% split(String, RegExp) -> {ok,[SubString]} | {error,E}.
%% split(String, RegExp, Flags) -> {ok,[SubString]} | {error,E}.
%%  Split a string into substrings where the RegExp describes the
%%  field seperator. The RegExp " " is specially treated.

split(S, RegExp) -> split(S, RegExp, []).	%Default flags
split(S, Regexp, Fls) -> split1(S, Regexp, parse_cflags(Fls)).

split1(S, " ", Fl) -> split1(S, "[ \t]+", true, Fl);
split1(S, RegExp, Fl) -> split1(S, RegExp, false, Fl).

split1(S, RegExp, Trim, Fl) ->
    case compile1(RegExp, Fl) of
	{ok,Nfa} when is_binary(S) ->
	    %% Match against a binary.
	    split_bin(S, Nfa, Trim, Fl);
	{ok,Nfa} ->
	    %% Match against a string.
	    split_str(S, Nfa, Trim, Fl);
	Error -> Error
    end.

split_str(S, Nfa, Trim, Fl) ->
    case Fl#cflags.sub of
	true ->
	    case ssplit_str(S, 1, S, 1, bos, Nfa, Trim) of
		[[],_|Ss] when Trim -> {ok,Ss};
		Ss -> {ok,Ss}
	    end;
	false ->
	    case split_str(S, 1, S, 1, bos, Nfa, Trim) of
		[[]|Ss] when Trim -> {ok,Ss};
		Ss -> {ok,Ss}
	    end
    end.

split_str(Ss, Ps, Cs0, P, Pc0, Nfa, Trim) ->
    case next_match_str(Cs0, P, Pc0, Nfa) of
	{match,St,0,_,_,[Pc1|Cs1]} ->
	    %% Ignore zero length matches.
	    split_str(Ss, Ps, Cs1, St+1, Pc1, Nfa, Trim);
	{match,St,0,_,_,[]} -> [substr(Ss, 1, St-Ps)];
	{match,St,Len,_,Pc1,Cs1} ->
	    St1 = St+Len,
	    [substr(Ss, 1, St-Ps)|
	     split_str(Cs1, St1, Cs1, St1, Pc1, Nfa, Trim)];
	nomatch ->
	    if Trim, Ss == [] -> [];
	       true -> [Ss]
	    end
    end.

ssplit_str(Ss, Ps, Cs0, P, Pc0, Nfa, Trim) ->
    case next_smatch_str(Cs0, P, Pc0, Nfa) of
	{match,St,0,_,_,_,[Pc1|Cs1]} ->
	    %% Ignore zero length matches.
	    ssplit_str(Ss, Ps, Cs1, St+1, Pc1, Nfa, Trim);
	{match,St,0,Cs,_,Subs0,[]} ->
	    Subs1 = fix_subs_str(Subs0, St, Cs),
	    [substr(Ss, 1, St-Ps),Subs1];
	{match,St,Len,Cs,Pc1,Subs0,Cs1} ->
	    St1 = St+Len,
	    Subs1 = fix_subs_str(Subs0, St, Cs),
	    [substr(Ss, 1, St-Ps),Subs1|
	     ssplit_str(Cs1, St1, Cs1, St1, Pc1, Nfa, Trim)];
	nomatch ->
	    if Trim, Ss == [] -> [];
	       true -> [Ss]
	    end
    end.

split_bin(S, Nfa, Trim, Fl) ->
    case Fl#cflags.sub of
	true ->
	    case ssplit_bin(S, 1, 1, bos, Nfa, Trim) of
		[<<>>,_|Ss] when Trim -> {ok,Ss};
		Ss -> {ok,Ss}
	    end;
	false ->
	    case split_bin(S, 1, 1, bos, Nfa, Trim) of
		[<<>>|Ss] when Trim -> {ok,Ss};
		Ss -> {ok,Ss}
	    end
    end.

split_bin(Bin, Ps, P, Pc0, Nfa, Trim) ->
    case next_match_bin(Bin, P, Pc0, Nfa) of
	{match,St,0,_} when St =< size(Bin) ->
	    %% Ignore zero length matches.
	    split_bin(Bin, Ps, St+1, unknown, Nfa, Trim);
	{match,St,0,_} -> [sub_bin(Bin, Ps, St-Ps)];
	{match,St,Len,Pc1} ->
	    St1 = St+Len,
	    [sub_bin(Bin, Ps, St-Ps)|split_bin(Bin, St1, St1, Pc1, Nfa, Trim)];
	nomatch ->
	    if Trim, P > size(Bin) -> [];
	       P > size(Bin) -> [<<>>];
	       true -> [sub_bin(Bin, Ps)]
	    end
    end.

ssplit_bin(Bin, Ps, P, Pc0, Nfa, Trim) ->
    case next_smatch_bin(Bin, P, Pc0, Nfa) of
	{match,St,0,_,_} when St =< size(Bin) ->
	    ssplit_bin(Bin, Ps, St+1, unknown, Nfa, Trim);
	{match,St,0,_,Subs0} ->
     	    Subs1 = fix_subs_bin(Subs0, Bin),
	    [sub_bin(Bin, Ps, St-Ps),Subs1];
	{match,St,Len,Pc1,Subs0} ->
	    St1 = St+Len,
	    Subs1 = fix_subs_bin(Subs0, Bin),
	    [sub_bin(Bin, Ps, St-Ps),Subs1|
	     ssplit_bin(Bin, St1, St1, Pc1, Nfa, Trim)];
	nomatch ->
	    if Trim, P > size(Bin) -> [];
	       P > size(Bin) -> [<<>>];
	       true -> [sub_bin(Bin, Ps)]
	    end
    end.

%% fix_subs_str(Subs, StartPos, String) -> {{St,Len,Str}}.
%% fix_subs_bin(Subs, Bin) -> {{St,Len,Str}}.
%% Take a subexpr structure from the regexp machine and convert it
%% into return format.

fix_subs_str(Subs, St, S) ->
    Subsl = fix_subs_str(Subs, St, S, size(Subs), []),
    list_to_tuple(Subsl).

fix_subs_str(_, _, _, 0, Ss) -> Ss;
fix_subs_str(Subs, P, S, N, Ss) ->
     E = case element(N, Subs) of
	     [L,St] -> {-St,L,substr(S, -St-P+1, L)};
	     [] -> undefined
	 end,
    fix_subs_str(Subs, P, S, N-1, [E|Ss]).

fix_subs_bin(Subs, Bin) ->
    Subsl = fix_subs_bin(Subs, Bin, size(Subs), []),
    list_to_tuple(Subsl).

fix_subs_bin(_, _, 0, Ss) -> Ss;
fix_subs_bin(Subs, Bin, N, Ss) ->
     E = case element(N, Subs) of
	     [L,St] -> {-St,L,bin_to_list(Bin, -St, L)};
	     [] -> undefined
	 end,
    fix_subs_bin(Subs, Bin, N-1, [E|Ss]).

%% bin_to_list(Binary, Start) -> Chars.
%% bin_to_list(Binary, Start, Length) -> Chars.
%%  As it should be!

%%bin_to_list(Bin, St) -> binary_to_list(Bin, St, size(Bin)).

bin_to_list(_, _, 0) -> [];
bin_to_list(Bin, St, L) -> binary_to_list(Bin, St, St+L-1).

sub_bin(Bin, St) ->
    St1 = St - 1,
    <<_:St1/binary,Sub/binary>> = Bin,
    Sub.

sub_bin(Bin, St, Len) ->
    St1 = St - 1,
    <<_:St1/binary,Sub:Len/binary,_/binary>> = Bin,
    Sub.

%% The NFA engines.
%%  We have two separate engines depending on whether we want to
%%  capture sub-expressions. Both have a top-level driver for strings
%%  and binaries. We need to do one character lookahead to get correct
%%  end of string behaviour as we match both [] and [$\n]. This is a
%%  pain!

%% next_match_str(String, StartPos, PrevChar, NFA) ->
%%      {match,MatchStart,MatchLength,MatchChars,MatchLastC,RestChars} |
%%      nomatch.
%%  Find the next match in String. Try successive positions until
%%  either a match is found or we reach the end of the string.

next_match_str(Cs, P, Pc, #nfa{nfa=Nfa,start=Start}) ->
    next_match_str(Cs, P, Pc, Nfa, Start).

next_match_str([C|Cs1]=Cs0, P0, Pc0, Nfa, Start) ->
    case nfa_str(Cs0, P0, Pc0, Nfa, [Start], nomatch) of
	{match,P1,Pc1,Cs} -> {match,P0,P1-P0,Cs0,Pc1,Cs};
	nomatch -> next_match_str(Cs1, P0+1, C, Nfa, Start)
    end;
next_match_str([], P0, Pc0, Nfa, Start) ->
    case nfa_str([], P0, Pc0, Nfa, [Start], nomatch) of
	{match,P1,Pc1,Cs} -> {match,P0,P1-P0,[],Pc1,Cs};
	nomatch -> nomatch
    end.

%% nfa_str(Chars, Pos, PrevChar, NFA, States, Accept) ->
%%      {match,NextPos,LastChar,Rest} | nomatch.
%%  Run the NFA machine over binary starting at one position until we
%%  either have a match or not a match.

nfa_str(_, _, _, _, [], A) -> A;		%No matching states
nfa_str([C|Cs1]=Cs0, P, Pc, Nfa, Ss0, A) ->
    Cur = {Pc,P,C},
    case step(Ss0, Cur, Nfa) of
	{Ss1,true} ->
	    nfa_str(Cs1, P+1, C, Nfa, Ss1, {match,P,Pc,Cs0});
	{Ss1,false} ->
	    nfa_str(Cs1, P+1, C, Nfa, Ss1, A)
    end;
nfa_str([], P, Pc, Nfa, Ss, A) ->		%No more characters
    Cur = {Pc,P,eos},
    case step(Ss, Cur, Nfa) of
	{_,true} -> {match,P,Pc,[]};
	{_,false} -> A
    end.

%% next_match_bin(Binary, StartPos, PrevC, NFA) ->
%%      {match,MatchStart,MatchLength,MatchLastC} | nomatch.
%%  Find the next match in Binary. Try successive positions until
%%  either a match is found or we reach the end of the string.
%%  Somtimes it can be very difficult for caller to work out previous
%%  char in the middle of a binary, if PrevChar is 'unknown' we do it
%%  for them.

next_match_bin(Bin, 1, Pc, #nfa{nfa=Nfa,start=Start}) ->
    next_match_bin_1(Bin, 1, Pc, Nfa, Start);
next_match_bin(Bin, P, unknown, #nfa{nfa=Nfa,start=Start}) ->
    Pm2 = P-2,
    <<_:Pm2/binary,Pc,Bin1/binary>> = Bin,
    next_match_bin_1(Bin1, P, Pc, Nfa, Start);
next_match_bin(Bin, P, Pc, #nfa{nfa=Nfa,start=Start}) ->
    Pm1 = P-1,
    <<_:Pm1/binary,Bin1/binary>> = Bin,
    next_match_bin_1(Bin1, P, Pc, Nfa, Start).

next_match_bin_1(<<C,Bin1/binary>>=Bin, P0, Pc0, Nfa, Start) ->
    case nfa_bin(Bin, P0, Pc0, Nfa, [Start], nomatch) of
	{match,P1,Pc1} -> {match,P0,P1-P0,Pc1};
	nomatch -> next_match_bin_1(Bin1, P0+1, C, Nfa, Start)
    end;
next_match_bin_1(<<>>=Bin, P0, Pc0, Nfa, Start) ->
    case nfa_bin(Bin, P0, Pc0, Nfa, [Start], nomatch) of
	{match,P1,Pc1} -> {match,P0,P1-P0,Pc1};
	nomatch -> nomatch
    end.

%% nfa_bin(Binary, Pos, PrevC, NFA, States, Accept) ->
%%       {match,NextPos,LastC} | nomatch.
%%  Run the NFA machine over binary starting at one position until we
%%  either have a match or not a match.

nfa_bin(_, _, _, _, [], A) -> A;		%No matching states
nfa_bin(<<C,Bin/binary>>, P, Pc, Nfa, Ss0, A) ->
    Cur = {Pc,P,C},
    case step(Ss0, Cur, Nfa) of
	{Ss1,true} ->
	    nfa_bin(Bin, P+1, C, Nfa, Ss1, {match,P,Pc});
	{Ss1,false} ->
	    nfa_bin(Bin, P+1, C, Nfa, Ss1, A)
    end;
nfa_bin(<<>>, P, Pc, Nfa, Ss0, A) ->
    Cur = {Pc,P,eos},
    case step(Ss0, Cur, Nfa) of
	{_,true} -> {match,P,Pc};
	{_,false} -> A
    end.

%% step(States, CurrentState, Nfa) -> {NewStates,Accept}.
%% step(States, CurrentState, Nfa, Seen, Accept, NewStates) ->
%%      {NewStates,Accept}.
%% step(State, CurrentState, Nfa, Seen, Accept, NewStates, States) ->
%%      {NewStates,Accept}.
%%
%%  This is a combination of eclosure and move from the dragon
%%  book. First traverse the e-closure from State and then move over
%%  character states. We need to keep track of already seen states to
%%  avoid looping.
%%
%%  CurrentState = {PrevChar,Pos,NextChar}
%%
%%  N.B. We do a bit of trickery here with the argument order to
%%  minimise the shifting of arguments. Get to know your compiler!

step([S|Ss], Cur, Nfa) ->
    step(S, Cur, Nfa, [], false, [], Ss);
step([], _, _) -> {[],false}.

step([S|Ss], Cur, Nfa, Seen, A, NewS) ->
    step(S, Cur, Nfa, Seen, A, NewS, Ss); %More efficient argument order
step([], _, _, _, A, NewS) -> {NewS,A}.

step(S, Cur, Nfa, Seen, A, NewS, Ss) ->
    %% Must check if we have already looked at this state as it is
    %% possible to get loops. This will also catch multiple references
    %% to c/nstates.
    case member(S, Seen) of
	true -> step(Ss, Cur, Nfa, Seen, A, NewS);
	false ->
	    Seen1 = [S|Seen],
	    case element(S, Nfa) of
		%% Epsilon states.
		#estate{s1=S1,s2=S2} ->
		    step(S1, Cur, Nfa, Seen1, A, NewS, [S2|Ss]);
		%% Just ignore parentheses states here.
		#lstate{s=S1} -> step(S1, Cur, Nfa, Seen, A, Ss);
		#rstate{s=S1} -> step(S1, Cur, Nfa, Seen, A, Ss);
		%% Position states.
		#pstate{t=bos,s=N} ->
		    if element(2, Cur) == 1 ->
			    step(N, Cur, Nfa, Seen1, A, NewS, Ss);
		       true -> step(Ss, Cur, Nfa, Seen1, A, NewS)
		    end;
		#pstate{t=eos,s=N} ->
		    if element(3, Cur) == eos ->
			    step(N, Cur, Nfa, Seen1, A, NewS, Ss);
		       true -> step(Ss, Cur, Nfa, Seen1, A, NewS)
		    end;
		#pstate{t=bol,s=N} ->
		    if element(1, Cur) == $\n ; element(2, Cur) == 1 ->
			    step(N, Cur, Nfa, Seen1, A, NewS, Ss);
		       true -> step(Ss, Cur, Nfa, Seen1, A, NewS)
		    end;
		#pstate{t=eol,s=N} ->
		    if element(3, Cur) == $\n ->
			    step(N, Cur, Nfa, Seen1, A, NewS, Ss);
		       true -> step(Ss, Cur, Nfa, Seen1, A, NewS)
		    end;
		%% Accept state.
		#astate{} -> step(Ss, Cur, Nfa, Seen1, true, NewS);
		%% Character states.
		#cstate{c=C,s=N} when C == element(3, Cur) ->
		    step(Ss, Cur, Nfa, Seen1, A, [N|NewS]);
		#cstate{} ->
		    step(Ss, Cur, Nfa, Seen1, A, NewS);
		#nstate{cc=Cc,s=N} ->
		    case match_char(element(3, Cur), Cc) of
			true -> step(Ss, Cur, Nfa, Seen1, A, [N|NewS]);
			false -> step(Ss, Cur, Nfa, Seen1, A, NewS)
		    end
	    end
    end.

%% match_char(Char, Class) -> true|false.
%%  Returns whetjer Char, is in Class.

match_char(C, [{C1,C2}|_Cc]) when C >= C1, C =< C2 -> true;
match_char(C, [C|_Cc]) -> true;
match_char(C, [_|Cc]) -> match_char(C, Cc);
match_char(_, []) -> false.

%% next_smatch_str(String, StartPos, PrevChar, NFA) ->
%%      {match,Start,Length,Chars,LastC,Subs,RestChars} | nomatch.
%%  Find the next match in String. Try successive positions until
%%  either a match is found or we reach the end of the string.

next_smatch_str(Cs, P, Pc, #nfa{nfa=Nfa,start=Start,nsub=Nsub}) ->
    Subs = erlang:make_tuple(Nsub, []),
    next_smatch_str(Cs, P, Pc, Nfa, {Start,Subs}).

next_smatch_str([C|Cs1]=Cs0, P0, Pc0, Nfa, Start) ->
    case nfa_str_s(Cs0, P0, Pc0, Nfa, [Start], nomatch) of
	{match,P1,Subs,Pc1,Cs} -> {match,P0,P1-P0,Cs0,Pc1,Subs,Cs};
	nomatch -> next_smatch_str(Cs1, P0+1, C, Nfa, Start)
    end;
next_smatch_str([], P0, Pc0, Nfa, Start) ->
    case nfa_str_s([], P0, Pc0, Nfa, [Start], nomatch) of
	{match,P1,Subs,Pc1,Cs} -> {match,P0,P1-P0,[],Pc1,Subs,Cs};
	nomatch -> nomatch
    end.

%% Must do eclosure and parentheses marking when we have a new
%% character.

%% nfa_str_s(Chars, Pos, PrevChar, NFA, States, Accept) ->
%%      {match,Subs,NextPos,PrevChar,Rest} | nomatch.
%%  Run the NFA machine over binary starting at one position until we
%%  either have a match or not a match.

nfa_str_s(_, _, _, _, [], A) -> A;		%No matching states
nfa_str_s([C|Cs1]=Cs0, P, Pc, Nfa, Ss0, A) ->
    Cur = {Pc,P,C},
    case step_s(Ss0, Cur, Nfa) of
	{Ss1,none} ->
	    nfa_str_s(Cs1, P+1, C, Nfa, Ss1, A);
	{Ss1,Asubs} ->
	    nfa_str_s(Cs1, P+1, C, Nfa, Ss1, {match,P,Asubs,Pc,Cs0})
    end;
nfa_str_s([], P, Pc, Nfa, Ss, A) ->			%No more characters
    Cur = {Pc,P,eos},
    case step_s(Ss, Cur, Nfa) of
	{_Ss1,none} ->
	    A;
	{_Ss1,Asubs} ->
	    {match,P,Asubs,Pc,[]}
    end.

%% next_smatch_bin(Binary, StartPos, PrevChar, NFA) ->
%%      {match,Start,Length,LastC,Subs} | nomatch.
%%  Find the next match in Binary. Try successive positions until
%%  either a match is found or we reach the end of the string.
%%  Somtimes it can be very difficult for caller to work out previous
%%  char in the middle of a binary, if PrevChar is 'unknown' we do it
%%  for them.

next_smatch_bin(Bin, 1, Pc, #nfa{nfa=Nfa,start=Start,nsub=Nsub}) ->
    Subs = erlang:make_tuple(Nsub, []),
    next_smatch_bin_1(Bin, 1, Pc, Nfa, {Start,Subs});
next_smatch_bin(Bin, P, unknown, #nfa{nfa=Nfa,start=Start,nsub=Nsub}) ->
    Pm2 = P-2,
    <<_:Pm2/binary,Pc,Bin1/binary>> = Bin,
    Subs = erlang:make_tuple(Nsub, []),
    next_smatch_bin_1(Bin1, P, Pc, Nfa, {Start,Subs});
next_smatch_bin(Bin, P, Pc, #nfa{nfa=Nfa,start=Start,nsub=Nsub}) ->
    Pm1 = P-1,
    <<_:Pm1/binary,Bin1/binary>> = Bin,
    Subs = erlang:make_tuple(Nsub, []),
    next_smatch_bin_1(Bin1, P, Pc, Nfa, {Start,Subs}).

next_smatch_bin_1(<<C,Bin1/binary>>=Bin, P0, Pc0, Nfa, Start) ->
    case nfa_bin_s(Bin, P0, Pc0, Nfa, [Start], nomatch) of
	{match,P1,Subs,Pc1} -> {match,P0,P1-P0,Pc1,Subs};
	nomatch -> next_smatch_bin_1(Bin1, P0+1, C, Nfa, Start)
    end;
next_smatch_bin_1(<<>>=Bin, P0, Pc0, Nfa, Start) ->
    case nfa_bin_s(Bin, P0, Pc0, Nfa, [Start], nomatch) of
	{match,P1,Subs,Pc1} -> {match,P0,P1-P0,Pc1,Subs};
	nomatch -> nomatch
    end.

%% nfa_bin_s(Binary, Pos, NFA, States, Accept) ->
%%      {match,Subs,NextPos} | nomatch.
%%  Run the NFA machine over binary starting at one position until we
%%  either have a match or not a match.

nfa_bin_s(_, _, _, _, [], A) -> A;			%No matching states
nfa_bin_s(<<C,Bin/binary>>, P, Pc, Nfa, Ss0, A) ->
    Cur = {Pc,P,C},
    case step_s(Ss0, Cur, Nfa) of
	{Ss1,none} ->
	    nfa_bin_s(Bin, P+1, C, Nfa, Ss1, A);
	{Ss1,Asubs} ->
	    nfa_bin_s(Bin, P+1, C, Nfa, Ss1, {match,P,Asubs,Pc})
    end;
nfa_bin_s(<<>>, P, Pc, Nfa, Ss, A) ->			%No more characters
    Cur = {Pc,P,eos},
    case step_s(Ss, Cur, Nfa) of
	{_Ss1,none} ->
	    A;
	{_Ss1,Asubs} ->
	    {match,P,Asubs,Pc}
    end.

%% step_s(States, CurrentState, Nfa) -> {NewStates,Accept}.
%% step_s(States, CurrentState, Nfa, Accept, NewStates) ->
%%      {NewStates,Accept}.
%% step_s(States, CurrentState, Nfa, Seen, Accept, NewStates) ->
%%      {NewStates,Accept}.
%% step_s(State, CurrentState, Nfa, Seen, Accept, NewStates, States) ->
%%      {NewStates,Accept}.
%%
%%  This is a combination of eclosure and move from the dragon
%%  book. First traverse the e-closure from State and then move over
%%  character states. We need to keep track of already seen states to
%%  avoid looping.
%%
%%  CurrentState = {PrevChar,Pos,NextChar}
%%
%%  N.B. We do a bit of trickery here with the argument order to minimise
%%  the shifting of arguments. Get to know your compiler!

step_s(Ss, Cur, Nfa) ->
    step_s(Ss, Cur, Nfa, none, []).

%% step_s([{State,Subs}], CurrentState, Nfa, AcceptSubs, NewStates) ->
%%      {NewStates,AcceptSubs}.
%%  Each separate {State,Subs} pair here must be treated as a separate
%%  "thread" and traversed separately. This is not a problem when we
%%  are not saving subexprs but here unless we do this it could mean
%%  that a "better" subexpr is lost because we have already "seen"
%%  this state with a worse subexpr.

step_s([S|Ss], Cur, Nfa, A0, NewS0) ->
    {NewS1,A1} = step_s(S, Cur, Nfa, [], A0, NewS0, []),
    step_s(Ss, Cur, Nfa, A1, NewS1);
step_s([], _, _, A, NewS) -> {NewS,A}.

step_s([S|Ss], Cur, Nfa, Seen, A, NewS) ->
    step_s(S, Cur, Nfa, Seen, A, NewS, Ss);
step_s([], _, _, _, A, NewS) -> {NewS,A}.

step_s({S,Subs0}, Cur, Nfa, Seen, A, NewS, Ss) ->
    %% Must check if we have already looked at this state as it is
    %% possible to get loops. This will also catch multiple references
    %% to c/nstates.
    case member(S, Seen) of
	true -> step_s(Ss, Cur, Nfa, Seen, A, NewS);
	false ->
	    Seen1 = [S|Seen],
	    case element(S, Nfa) of
		%% Epsilon states.
		#estate{s1=S1,s2=S2} ->
		    step_s({S1,Subs0}, Cur, Nfa, Seen1, A, NewS,
			       [{S2,Subs0}|Ss]);
		%% Parenthesis states.
		#lstate{s=S1,n=N} ->
		    P = element(2, Cur),
		    Subs1 = add_lparen(N, P, Subs0),
		    step_s({S1,Subs1}, Cur, Nfa, Seen1, A, NewS, Ss);
		#rstate{s=S1,n=N} ->
		    P = element(2, Cur),
		    Subs1 = add_rparen(N, P, Subs0),
		    step_s({S1,Subs1}, Cur, Nfa, Seen1, A, NewS, Ss);
		%% Position states.
		#pstate{t=bos,s=N} ->
		    if element(2, Cur) == 1 ->
			    step_s(N, Cur, Nfa, Seen1, A, NewS, Ss);
		       true -> step_s(Ss, Cur, Nfa, Seen1, A, NewS)
		    end;
		#pstate{t=eos,s=N} ->
		    if element(3, Cur) == eos ->
			    step_s(N, Cur, Nfa, Seen1, A, NewS, Ss);
		       true -> step_s(Ss, Cur, Nfa, Seen1, A, NewS)
		    end;
		#pstate{t=bol,s=N} ->
		    if element(1, Cur) == $\n ; element(2, Cur) == 1 ->
			    step_s(N, Cur, Nfa, Seen1, A, NewS, Ss);
		       true -> step_s(Ss, Cur, Nfa, Seen1, A, NewS)
		    end;
		#pstate{t=eol,s=N} ->
		    if element(3, Cur) == $\n ->
			    step_s(N, Cur, Nfa, Seen1, A, NewS, Ss);
		       true -> step_s(Ss, Cur, Nfa, Seen1, A, NewS)
		    end;
		%% Accept state.
		#astate{} ->
		    Asubs = best_subs(A, Subs0),
		    step_s(Ss, Cur, Nfa, Seen1, Asubs, NewS);
		%% Character states.
		#cstate{c=C,s=N} when C == element(3, Cur) ->
		    NewS1 = add_state_s(N, Subs0, NewS, NewS),
		    step_s(Ss, Cur, Nfa, Seen, A, NewS1);
		#cstate{} ->
		    step_s(Ss, Cur, Nfa, Seen, A, NewS);
		#nstate{cc=Cc,s=N} ->
		    case match_char(element(3, Cur), Cc) of
			true ->
			    NewS1 = add_state_s(N, Subs0, NewS, NewS),
			    step_s(Ss, Cur, Nfa, Seen, A, NewS1);
			false ->
			    step_s(Ss, Cur, Nfa, Seen, A, NewS)
		    end
	    end
    end.

%% Want the leftmost longest for sub exprs by saving each parenthesis
%% pair as [Length,-Start] | [] then a simple comparison of the subs
%% tuples gives the right answer. Bigger is better!
%%
%% For each lpar the -Start is pushed on the list, at rpar the new
%% length is checked with the previous one and the best chosen.

%% best_subs(OldSubs, NewSubs) -> BestSubs.

best_subs(O, N) when O >= N -> O;
best_subs(_, N) -> N.

add_state_s(S, Subs, [{S,Subs1}|_], All) when Subs1 >= Subs -> All;
add_state_s(S, Subs, [_|Ss], All) -> add_state_s(S, Subs, Ss, All);
add_state_s(S, Subs, [], All) -> [{S,Subs}|All].

add_lparen(N, P, Subs) ->
    %%Negative start to make easier comparison, bigger is better!
    setelement(N, Subs, [-P|element(N, Subs)]).

add_rparen(N, P, Subs) ->
    case element(N, Subs) of
	[P1] -> setelement(N, Subs, [P+P1,P1]);
	[P1|[L2,_]=Old] ->
	    %% Pick the best.
	    L1 = P+P1,
	    setelement(N, Subs,
		       if L1 > L2 -> [L1,P1];
			  true -> Old
		       end)
    end.
